"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = __importStar(require("ramda"));
const constants_1 = require("../constants");
const selectors_1 = require("../selectors");
const verifiers_1 = require("../verifiers");
const formatFieldDataForMutation_1 = require("./formatFieldDataForMutation");
const omitDeep_1 = require("./omitDeep");
const errors_1 = require("../errors");
/**
 * Formats entity data for create or update mutation based on passed schema.
 * @param {MutationType} type - The type of the mutation.
 * @param {string} tableName - The name of the table from the 8base API.
 * @param {Object} data - The entity data for format.
 * @param {Schema} schema - The schema of the used tables from the 8base API.
 */
const formatDataForMutation = (type, data, { tableName, appName, schema }, options = {}) => {
    if (R.not(type in constants_1.MUTATION_TYPE)) {
        throw new errors_1.SDKError(errors_1.ERROR_CODES.INVALID_ARGUMENT, errors_1.PACKAGES.UTILS, `Invalid mutation type: ${type}`);
    }
    if (R.isNil(data)) {
        return data;
    }
    const tableSchema = selectors_1.tablesListSelectors.getTableByName(schema, tableName, appName);
    if (!tableSchema) {
        throw new errors_1.SDKError(errors_1.ERROR_CODES.TABLE_NOT_FOUND, errors_1.PACKAGES.UTILS, `Table schema with ${tableName} name not found in schema.`);
    }
    const formatedData = R.reduce((result, fieldName) => {
        if (fieldName === '_description' ||
            fieldName === '__typename' ||
            (verifiers_1.isFilesTable(tableSchema) && !constants_1.MUTATION_FILE_FIELDS.includes(fieldName))) {
            return result;
        }
        const fieldSchema = selectors_1.tableSelectors.getFieldByName(tableSchema, fieldName);
        const { skip, mutate, ignoreNonTableFields = true } = options;
        if (!fieldSchema) {
            if (ignoreNonTableFields) {
                return result;
            }
            return Object.assign({}, result, { [fieldName]: data[fieldName] });
        }
        if (typeof skip === 'function' && skip(data[fieldName], fieldSchema)) {
            return result;
        }
        if (verifiers_1.isMetaField(fieldSchema)) {
            return result;
        }
        let formatedFieldData = data[fieldName];
        if ((verifiers_1.isFileField(fieldSchema) || verifiers_1.isRelationField(fieldSchema)) && verifiers_1.isListField(fieldSchema)) {
            if (R.isNil(formatedFieldData)) {
                formatedFieldData = [];
            }
            else {
                formatedFieldData = R.reject(R.isNil, formatedFieldData);
            }
            if (formatedFieldData.length === 0 && type === constants_1.MUTATION_TYPE.CREATE) {
                return result;
            }
        }
        formatedFieldData = formatFieldDataForMutation_1.formatFieldDataForMutation(type, formatedFieldData, { fieldSchema, schema });
        if (typeof mutate === 'function') {
            formatedFieldData = mutate(formatedFieldData, data[fieldName], fieldSchema);
        }
        return Object.assign({}, result, { [fieldName]: formatedFieldData });
    }, {}, R.keys(data));
    return omitDeep_1.omitDeep(['_description', '__typename'], formatedData);
};
exports.formatDataForMutation = formatDataForMutation;
//# sourceMappingURL=formatDataForMutation.js.map