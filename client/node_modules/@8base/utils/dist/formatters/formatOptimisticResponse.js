"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = __importStar(require("ramda"));
const schema_name_generator_1 = require("@8base/schema-name-generator");
const constants_1 = require("../constants");
const selectors_1 = require("../selectors");
const errors_1 = require("../errors");
const formatFileOptimisticResponse = (recordId, requestFieldData, fieldSchema) => {
    const isList = selectors_1.tableFieldSelectors.isListField(fieldSchema);
    const fieldOptimisticResponse = isList
        ? {
            items: [
                ...requestFieldData
                    .filter((fileItem) => !!fileItem.id)
                    .map((fileItem) => (Object.assign({ __typename: 'File' }, fileItem))),
                ...requestFieldData
                    .filter((fileItem) => !fileItem.id)
                    .map((fileItem, index) => ({
                    __typename: 'File',
                    id: `__optimistic_id_${recordId}_${index}__`,
                    shareUrl: '__optimistic_value__',
                    meta: {},
                    downloadUrl: fileItem.downloadUrl,
                    fileId: fileItem.fileId,
                    filename: fileItem.filename,
                })),
            ],
            count: requestFieldData.length,
            __typename: 'FileListResponse',
        }
        : {
            __typename: 'File',
            id: '__optimistic_id__',
            shareUrl: '__optimistic_value__',
            meta: {},
            downloadUrl: requestFieldData.downloadUrl,
            fileId: requestFieldData.fileId,
            filename: requestFieldData.filename,
        };
    return fieldOptimisticResponse;
};
/**
 * Formats entity data for create or update mutation based on passed schema.
 * @param {MutationType} type - The type of the mutation.
 * @param {Object} requestData - The entity data to request.
 * @param {Object} schema - The schema of the used tables from the 8base API.
 */
const formatOptimisticResponse = (type, { requestData, recordId }, { tableName, appName, schema }, options = {}) => {
    if (R.not(type in constants_1.MUTATION_TYPE)) {
        throw new errors_1.SDKError(errors_1.ERROR_CODES.INVALID_ARGUMENT, errors_1.PACKAGES.UTILS, `Invalid mutation type: ${type}.`);
    }
    if (R.equals(type, 'CREATE')) {
        throw new errors_1.SDKError(errors_1.ERROR_CODES.NOT_IMPLEMENTED, errors_1.PACKAGES.UTILS, `${type} mutation type is not supported yet.`);
    }
    if (R.isNil(requestData)) {
        return requestData;
    }
    const tableSchema = selectors_1.tablesListSelectors.getTableByName(schema, tableName, appName);
    if (!tableSchema) {
        throw new errors_1.SDKError(errors_1.ERROR_CODES.TABLE_NOT_FOUND, errors_1.PACKAGES.UTILS, `Table schema with ${tableName} name is not found in schema.`);
    }
    const formattedRepose = R.reduce((result, fieldName) => {
        const fieldSchema = selectors_1.tableSelectors.getFieldByName(tableSchema, fieldName);
        const fieldType = selectors_1.tableFieldSelectors.getFieldType(fieldSchema);
        const tableName = selectors_1.tableFieldSelectors.getTableName(fieldSchema);
        const { skip } = options;
        if (typeof skip === 'function' && skip(requestData[fieldName], fieldSchema)) {
            return result;
        }
        const requestFieldData = requestData[fieldName];
        let fieldOptimisticResponse = {};
        if (fieldType === constants_1.FIELD_TYPE.FILE) {
            fieldOptimisticResponse = formatFileOptimisticResponse(recordId, requestFieldData, fieldSchema);
        }
        else {
            // tslint:disable-next-line:no-console
            console.warn(`${fieldType} is not supported for optimistic response. ${fieldName} field will be ignored.`);
            return result;
        }
        return Object.assign({}, result, { [fieldName]: fieldOptimisticResponse });
    }, {}, R.keys(requestData));
    return {
        __typename: 'Mutation',
        [schema_name_generator_1.SchemaNameGenerator.getUpdateItemFieldName(tableName)]: Object.assign({ __typename: schema_name_generator_1.SchemaNameGenerator.getUpdateInputName(tableName).replace('UpdateInput', ''), id: recordId }, formattedRepose),
    };
};
exports.formatOptimisticResponse = formatOptimisticResponse;
//# sourceMappingURL=formatOptimisticResponse.js.map