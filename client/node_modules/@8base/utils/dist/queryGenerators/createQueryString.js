"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = __importStar(require("ramda"));
const constants_1 = require("../constants");
const selectors_1 = require("../selectors");
const errors_1 = require("../errors");
const DEFAULT_DEPTH = 1;
exports.createQueryString = (tablesList, tableId, queryObjectConfig = {}, prevKey = '') => {
    const table = selectors_1.tablesListSelectors.getTableById(tablesList, tableId);
    if (!table) {
        throw new errors_1.SDKError(errors_1.ERROR_CODES.TABLE_NOT_FOUND, errors_1.PACKAGES.UTILS, `Table with id ${tableId} not found`);
    }
    const { fields, name: tableName } = table;
    const { deep = DEFAULT_DEPTH, withMeta = true, relationItemsCount, includeColumns, permissions = {}, } = queryObjectConfig;
    let queryObject = '';
    fields
        .filter(field => {
        const isMeta = selectors_1.tableFieldSelectors.isMetaField(field);
        const isRelation = selectors_1.tableFieldSelectors.isRelationField(field);
        let shouldIncludeField = withMeta ? true : !isMeta;
        if (isRelation) {
            const refTableName = selectors_1.tableFieldSelectors.getRelationTableName(field);
            const refTableAllowed = R.pathOr(true, ['data', refTableName, 'permission', 'read', 'allow'], permissions);
            shouldIncludeField = refTableAllowed && shouldIncludeField;
        }
        else {
            const fieldAllowed = R.pathOr(true, ['data', tableName, 'permission', 'read', 'fields', field.name], permissions);
            shouldIncludeField = fieldAllowed && shouldIncludeField;
        }
        return shouldIncludeField;
    })
        .forEach(field => {
        let fieldContent = field.name;
        const isRelation = selectors_1.tableFieldSelectors.isRelationField(field);
        const isMissingRelation = selectors_1.tableFieldSelectors.isMissingRelationField(field);
        const isOneWayRelationField = selectors_1.tableFieldSelectors.isOneWayRelationField(field);
        const isFile = selectors_1.tableFieldSelectors.isFileField(field);
        const isSmart = selectors_1.tableFieldSelectors.isSmartField(field);
        const isList = selectors_1.tableFieldSelectors.isListField(field);
        const refTableId = selectors_1.tableFieldSelectors.getRelationTableId(field);
        const refTable = selectors_1.tablesListSelectors.getTableById(tablesList, refTableId);
        const isSettingsRefTable = selectors_1.tableFieldSelectors.isSystemField(field) &&
            selectors_1.tableFieldSelectors.getRelationTableName(field) === constants_1.SYSTEM_TABLES.SETTINGS;
        const isPermissionsRefTable = selectors_1.tableFieldSelectors.isSystemField(field) &&
            selectors_1.tableFieldSelectors.getRelationTableName(field) === constants_1.SYSTEM_TABLES.PERMISSIONS;
        const currentKeyString = prevKey ? `${prevKey}.${field.name}` : field.name;
        let isNotEmptyRelation = false;
        if (isSettingsRefTable || isPermissionsRefTable) {
            fieldContent = `{
          _description
        }`;
        }
        else if (isMissingRelation) {
            fieldContent = `{
          table
        }`;
        }
        else if (isRelation || isOneWayRelationField) {
            if (deep <= 1 || !refTableId || !refTable) {
                fieldContent = `{
              id
              _description
            }`;
            }
            else {
                const includeAllrelationFields = R.contains(currentKeyString, includeColumns || []);
                const relationIncludeColumns = includeAllrelationFields ? null : includeColumns;
                const innerFields = exports.createQueryString(tablesList, refTableId, {
                    deep: deep - 1,
                    includeColumns: relationIncludeColumns,
                    withMeta,
                }, currentKeyString);
                isNotEmptyRelation = !R.isEmpty(innerFields);
                fieldContent = `{
            id
            ${innerFields}
            _description
          }`;
            }
        }
        else if (isFile) {
            fieldContent = `{
          id
          fileId
          filename
          downloadUrl
          shareUrl
          meta
        }`;
        }
        else if (isSmart) {
            fieldContent = `{${field.fieldTypeAttributes.innerFields.reduce((accum, { name }) => {
                accum += `\n${name}`;
                return accum;
            }, '')}}`;
        }
        if (isList && (isRelation || isFile) && fieldContent !== null) {
            fieldContent = `{
          items ${fieldContent}
          count
        }`;
        }
        const needsInclude = !!includeColumns ? R.contains(currentKeyString, includeColumns) : true;
        if (fieldContent !== null && (needsInclude || isNotEmptyRelation)) {
            if (!!relationItemsCount && isList && isRelation) {
                queryObject += `\n${field.name}(first: ${relationItemsCount}) ${fieldContent}`;
            }
            else {
                queryObject += `\n${field.name} ${fieldContent}`;
            }
        }
    });
    return queryObject;
};
//# sourceMappingURL=createQueryString.js.map