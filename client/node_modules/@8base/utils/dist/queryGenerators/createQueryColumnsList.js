"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = __importStar(require("ramda"));
const selectors_1 = require("../selectors");
const capitalizeFirstLetter = (str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
};
exports.createQueryColumnsList = (tablesList, tableId, config = {}, prevKey = '') => {
    const { fields = [] } = selectors_1.tablesListSelectors.getTableById(tablesList, tableId) || {};
    const { deep = 1, withMeta = true, flatten = true, includeColumns } = config;
    const transformedList = fields
        .filter(field => {
        const isMeta = selectors_1.tableFieldSelectors.isMetaField(field);
        const isIdField = selectors_1.tableFieldSelectors.isIdField(field);
        if (isIdField) {
            return false;
        }
        return withMeta ? true : !isMeta;
    })
        .map(field => {
        const fieldName = selectors_1.tableFieldSelectors.getFieldName(field);
        const fieldType = selectors_1.tableFieldSelectors.getFieldType(field);
        const fieldTypeAttributes = selectors_1.tableFieldSelectors.getFieldTypesAttributes(field);
        const isRelation = selectors_1.tableFieldSelectors.isRelationField(field);
        const isFile = selectors_1.tableFieldSelectors.isFileField(field);
        const isList = selectors_1.tableFieldSelectors.isListField(field);
        const refTableId = selectors_1.tableFieldSelectors.getRelationTableId(field);
        const refTable = selectors_1.tablesListSelectors.getTableById(tablesList, refTableId);
        const currentKeyString = prevKey ? `${prevKey}.${fieldName}` : fieldName;
        const title = capitalizeFirstLetter(fieldName);
        const meta = {
            fieldType,
            fieldTypeAttributes,
            isList,
        };
        if (isFile) {
            return [
                {
                    meta,
                    name: currentKeyString,
                    title,
                },
            ];
        }
        else if (isRelation && isList) {
            return [
                {
                    name: currentKeyString,
                    title,
                    meta,
                },
            ];
        }
        else if (isRelation && refTableId && refTable && deep > 1) {
            const innerKeys = exports.createQueryColumnsList(tablesList, refTableId, { deep: deep - 1, withMeta, includeColumns }, currentKeyString);
            return flatten
                ? [...innerKeys, { name: currentKeyString, title, meta }]
                : { name: currentKeyString, title, meta, children: innerKeys };
        }
        else if (isRelation) {
            return [
                {
                    meta,
                    name: currentKeyString,
                    title,
                },
            ];
        }
        return [
            {
                meta,
                name: currentKeyString,
                title,
            },
        ];
    });
    return R.flatten(transformedList).filter(({ name }) => !!includeColumns ? R.contains(name, includeColumns) : true);
};
//# sourceMappingURL=createQueryColumnsList.js.map