"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _parser = require("graphql/language/parser");

var _printer = require("graphql/language/printer");

var _kinds = require("graphql/language/kinds");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isSelectionsEmpty = function isSelectionsEmpty(node) {
  return !node.selectionSet || !node.selectionSet.selections || node.selectionSet.selections.length === 0;
};

var removeDuplicatedLeafNodes = function removeDuplicatedLeafNodes(sourceNode) {
  if (isSelectionsEmpty(sourceNode)) {
    return sourceNode;
  }

  var newNode = _objectSpread({}, sourceNode);

  newNode.selectionSet.selections = newNode.selectionSet.selections.filter(function (selection, index, self) {
    return selection.kind !== _kinds.Kind.FIELD || selection.selectionSet || index === self.findIndex(function (selection2) {
      return selection2.kind === _kinds.Kind.FIELD && selection.name.value === selection2.name.value;
    });
  }).map(removeDuplicatedLeafNodes);
  return newNode;
};

var mergeDuplicatedNotLeafNodes = function mergeDuplicatedNotLeafNodes(sourceNode) {
  if (isSelectionsEmpty(sourceNode)) {
    return sourceNode;
  }

  var newNode = _objectSpread({}, sourceNode);

  if (sourceNode.selectionSet.selections.length <= 2) {
    newNode.selectionSet.selections = newNode.selectionSet.selections.map(mergeDuplicatedNotLeafNodes);
    return newNode;
  }

  var nodesToMerge = [];

  var findIndex = function findIndex(node1, node2) {
    return node1.kind === node2.kind && node1.name.value === node2.name.value && (!node1.alias && !node2.alias || node1.alias.value === node2.alias.value);
  };

  newNode.selectionSet.selections = newNode.selectionSet.selections.filter(function (selection, index, self) {
    if (selection.kind !== _kinds.Kind.FIELD) {
      return true;
    }

    if (!selection.selectionSet) {
      return true;
    }

    if (index === self.findIndex(function (selection2) {
      return findIndex(selection, selection2);
    })) {
      return true;
    }

    nodesToMerge = [].concat(_toConsumableArray(nodesToMerge), [selection]);
    return false;
  });
  nodesToMerge.forEach(function (node) {
    var index = newNode.selectionSet.selections.findIndex(function (selection) {
      return findIndex(selection, node);
    });
    newNode.selectionSet.selections[index].selectionSet.selections = [].concat(_toConsumableArray(newNode.selectionSet.selections[index].selectionSet.selections), _toConsumableArray(node.selectionSet.selections));
  });
  newNode.selectionSet.selections = newNode.selectionSet.selections.map(mergeDuplicatedNotLeafNodes);
  return newNode;
};

var replaceFragments = function replaceFragments(sourceNode, fragments) {
  if (isSelectionsEmpty(sourceNode)) {
    return sourceNode;
  }

  var newNode = _objectSpread({}, sourceNode);

  var foundFragments = [];
  newNode.selectionSet.selections = newNode.selectionSet.selections.filter(function (selection) {
    if (selection.kind !== _kinds.Kind.FRAGMENT_SPREAD) {
      return true;
    }

    if (!foundFragments.find(function (fragment) {
      return fragment.name.value === selection.name.value;
    })) {
      var fragment = fragments.find(function (fragment) {
        return fragment.name.value === selection.name.value;
      });

      if (!fragment) {
        throw Error("Found usage of unknown fragment ".concat(selection.name.value));
      }

      foundFragments = [].concat(_toConsumableArray(foundFragments), [fragment]);
    }

    return false;
  });
  newNode.selectionSet.selections = [].concat(_toConsumableArray(newNode.selectionSet.selections), _toConsumableArray(foundFragments.reduce(function (acc, fragment) {
    return [].concat(_toConsumableArray(fragment.selectionSet.selections), _toConsumableArray(acc));
  }, [])));
  newNode.selectionSet.selections = newNode.selectionSet.selections.map(function (selection) {
    return replaceFragments(selection, fragments);
  });
  return newNode;
};

var prettify = function prettify(source) {
  var noDuplicates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var document = (0, _parser.parse)(source);
  var fragments = document.definitions.filter(function (node) {
    return node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
  }).map(function (node, _, self) {
    return replaceFragments(node, self);
  });
  return document.definitions.filter(function (node) {
    return node.kind === _kinds.Kind.OPERATION_DEFINITION;
  }).map(function (operationNode) {
    var newOperationNode = _objectSpread({}, operationNode);

    newOperationNode.selectionSet.selections = newOperationNode.selectionSet.selections.map(function (selection) {
      return replaceFragments(selection, fragments);
    });

    if (noDuplicates) {
      newOperationNode.selectionSet.selections = newOperationNode.selectionSet.selections.map(function (selection) {
        return removeDuplicatedLeafNodes(mergeDuplicatedNotLeafNodes(selection));
      });
    }

    return newOperationNode;
  }).map(_printer.print).join('\n');
};

var _default = prettify;
exports.default = _default;